====================================
Gun Survivors

--------------------------
Source:
https://www.udemy.com/course/unreal-engine-2d/learn/lecture/44277214#overview

-----------------------------------

====================================
26. The Arena

Two Ways to Handle Sorting in 2D:
* Use distance from camera (e.g. Y value)
* Use TranslucentUnlitSpriteMaterial and set Rendering->Advanced->Translucency Sort Priority
  * Sprites with lower numbers are drawn below sprites with higher numbers

Collision:
* This is set on both the SpriteComponent and CapsuleComponents (if it has a capsule)

Camera:
* Added camera to scene, as game camera will be static
* Setting the in-scene camera for the player:
  * Details -> Auto Player Activation -> Auto Activate for Player: Player0
* Hide in-scene camera (prevent from blocking your view when editing the level)
  * Set Scale to 0.01

====================================
27. Flipbooks 101

In order to use Flipbook in the game, you must use a Flipbook component. Flipbook Components do not accept Sprites, so even if you have a single frame animation, you still need to make a Flipbook from the single Sprite.

====================================
28. Player Class & Blueprint

-------------------------
Setting up C++ portion
-------------------------

ATopDownCharacter

Components for 2D Characters:
#include "Components/CapsuleComponent.h"
#include "PaperFlipbookComponent.h"

UPROPERTIES:
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TObjectPtr<class UCapsuleComponent> CapsuleComponent;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TObjectPtr<class UPaperFlipbookComponent> PaperFlipbookComponent;

	VisibleAnywhere: Means we can see it in the Editor (cannot be edited at all)
	BlueprintReadWrite: Means we can read and write to it from Blueprint Graphs (i.e. Getters and Setters)

Create Components using:
CreateDefaultSubobject()

Set the root component of the object using:
SetRootComponent()
	CapsuleComponent = CreateDefaultSubobject<UCapsuleComponent>(TEXT("CapsuleComponent"));
	SetRootComponent(CapsuleComponent);

Create and attach a component to another component:
	CharacterFlipbookComponent = CreateDefaultSubobject<UPaperFlipbookComponent>(TEXT("CharacterFlipbookComponent"));
	CharacterFlipbookComponent->SetupAttachment(RootComponent);

Note:
RootComponent is set using SetRootComponent(), so you could also do: 
CharacterFlipbookComponent->SetupAttachment(CapsuleComponent);

NOTE:
If you are creating a SpringArm and a Child Camera, you would set them up like this:
	CameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT("CameraComponent"));
	CameraComponent->SetupAttachment(SpringArmComponent, USpringArmComponent::SocketName); // Attach camera to SpringArm's socket

-------------------------
Setting Up Blueprint
-------------------------
After creating a Blueprint class with our TopDownCharacter as the parent class, you will see the components in the Hierarchy.

Flipbook (CharacterFlipbookComponent):
* Set the Flipbook in the Details -> Sprite -> Source Flipbook
  * Play Rate changes the speed at which the flipbook animation is played.
* Turn off Sprite collision, as we will use the Capsule
* If not set, use TranslucentUnlitSpriteMaterial in order to set the Rendering->Advanced->Translucency Sort Priority

CapsuleComponent:
* Adjust CapsuleHalfHeight and CapsuleRadius around the sprite
* Change collision preset to Pawn
  * Set to "Pawn" because the owning object (the player) is a Pawn

--------------------------------------------------
Adding a player character to the scene for testing
--------------------------------------------------
* Drag a BP_Player into the scene.
* Allow this BP_Player instance to be controlled by the player:
  * Details -> Pawn -> Auto Possess Player: Player 0 (Changed from Disabled)
    * (Do this for testing until you update the GameMode with a Default Pawn class and a PlayerStart in the level)

====================================
29. The Game Mode

* Using GameModeBase as the parent class for GunSurvivorsGameMode: BP_GunSurvivorsGameMode
* Set BP_Player as the default player pawn class:
  * Open gamemode -> Class Defaults -> Classes -> Default Pawn Class:  Set to BP_Player
* Set BP_GunSurvivorsGameMode as the default Game Mode:
  * Edit -> Project Settings -> Project -> Maps & Modes-> Default Modes -> Default GameMode:  Set to BP_GunSurvivorsGameMode

====================================
30. Input System Setup

Two types of input assets created in the editor:
* Input Mapping Context
* Input Action

-------------------------
Setting up C++ portion
-------------------------

Include files:
#include "Components/InputComponent.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "InputActionValue.h"
#include "GameFramework/Controller.h"

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TObjectPtr<class UInputMappingContext> InputMappingContext;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TObjectPtr<class UInputAction> MoveInputAction;


EditAnywhere:      This means it can be edited (i.e. assigned) in the Blueprint Editor
BlueprintReadOnly: This means it can be accessed in Blueprint Graphs but not changed in Blueprint Grapsh (i.e. getter only)

Register the inputs in BeginPlay() using
UEnhancedInputLocalPlayerSubsystem::AddMappingContext

// Register Inputs from the EnhancedInputLocalPlayerSubsystem (which is accessed from the LocalPlayer)
if (APlayerController* PlayerController = Cast<APlayerController>(Controller))
{
	if (UEnhancedInputLocalPlayerSubsystem* InputSubsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))
	{
		InputSubsystem->AddMappingContext(InputMappingContext, 0);
	}
}

NOTE:
* TODO - Check if you can (or should get the subsystem like this:

// Register Inputs from the EnhancedInputLocalPlayerSubsystem (which is accessed from the LocalPlayer)
if (APlayerController* PlayerController = Cast<APlayerController>(Controller))
{
	if (ULocalPlayer* LocalPlayer = PlayerController->GetLocalPlayer())
	{
		if (UEnhancedInputLocalPlayerSubsystem* InputSubsystem = LocalPlayer->GetSubsystem<UEnhancedInputLocalPlayerSubsystem>())
		{
			InputSubsystem->AddMappingContext(InputMappingContext, 0, FModifyContextOptions());
		}
	}
}

========================================================================
31. Binding Actions

For binding actions, Bind a function which passes an object of type FInputActionValue:

	void MoveTriggered(const struct FInputActionValue& InputActionValue);
	void MoveCompleted(const struct FInputActionValue& InputActionValue);
	void Shoot(const struct FInputActionValue& InputActionValue);

Bind the functions in SetupPlayerInputComponent()
void ATopDownCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)

Since UInputComponent* PlayerInputComponent is being passed, we can cast this:

	if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
	{
		EnhancedInputComponent->BindAction(MoveInputAction, ETriggerEvent::Triggered, this, &ThisClass::MoveTriggered);
		EnhancedInputComponent->BindAction(MoveInputAction, ETriggerEvent::Completed, this, &ThisClass::MoveCompleted);
		EnhancedInputComponent->BindAction(MoveInputAction, ETriggerEvent::Canceled, this, &ThisClass::MoveCompleted);

		EnhancedInputComponent->BindAction(ShootInputAction, ETriggerEvent::Started, this, &ThisClass::Shoot);
		EnhancedInputComponent->BindAction(ShootInputAction, ETriggerEvent::Triggered, this, &ThisClass::Shoot);
	}

In the bound input functions, access the input values:
FVector2D MoveActionValue = InputActionValue.Get<FVector2d>();

========================================================================
32. Player Movement

Set the movement direction:
FVector2D MoveActionValue = InputActionValue.Get<FVector2d>();
MovementDirection = MoveActionValue;

Update player movement
void ATopDownCharacter::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	// Check if player can move
	if (bCanMove)
	{
		// Check if player has any input
		if (MovementDirection.Length() > 0.0f)
		{
			if (MovementDirection.Length() > 1.0f)
			{
				MovementDirection.Normalize(); // Note: We could also go MovementDirection.GetSafeNormal() and use that
			}

			// Get the distance to move this frame using the movement direction
			FVector2D DistanceToMove = MovementDirection * MovementSpeed * DeltaTime;

			// Get the current position of the player at this frame
			FVector CurrentLocation = GetActorLocation();

			// The player moves in the XZ plane
			FVector NewLocation = CurrentLocation + FVector(DistanceToMove.X, 0.0f, DistanceToMove.Y);

			// Set the player's new location
			SetActorLocation(NewLocation);
		}
	}
}


========================================================================
33. Switching Flipbooks

-------------------
Changing Flipbooks
-------------------
You need a reference to a UPaperFlipbook object.
* NOTE: This is DIFFERENT from a UPaperFlipbookComponent
* A UPaperFlipbook is a reference to the actual Flipbook ASSET

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "TopDownCharacter|Flipbook")
	TObjectPtr<class UPaperFlipbook> IdleFlipbook;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "TopDownCharacter|Flipbook")
	TObjectPtr<class UPaperFlipbook> RunFlipbook;

Set the Flipbook from the FlipbookComponent:
CharacterFlipbookComponent->SetFlipbook(RunFlipbook);
...
CharacterFlipbookComponent->SetFlipbook(IdleFlipbook);

------------------------------
Changing Flipbook Directions
------------------------------

You can do this in one of two ways:
* Negating a SCALE (-1)
* Rotating by 180 degrees

For example:
To make the player face LEFT:
* Setting the X scale of the flipbook to -1
OR
* Rotate around the Z axis by 180 degrees (Roll)

BOTH methods are VALID ways to do it. Here, we will be negating the scale

Getting the Scale of a Flipbook:
		FVector FlipbookScale = CharacterFlipbookComponent->GetComponentScale();

Setting the Scale of a Flipbook:
CharacterFlipbookComponent->SetWorldScale3D(FVector(-1.0f, 1.0f, 1.0f));


FVector FlipbookScale = CharacterFlipbookComponent->GetComponentScale();
if (MovementDirection.X < 0.0f)
{
	// Moving Left
	if (FlipbookScale.X > 0.0f)
	{
		// Flip the flipbook scale to face left (if it hasn't been flipped already)
		CharacterFlipbookComponent->SetWorldScale3D(FVector(-1.0f, 1.0f, 1.0f));
	}
}
else if (MovementDirection.X > 0.0f)
{
	// Moving Right
	if (FlipbookScale.X < 0.0f)
	{
		// Flip the flipbook scale to face left (if it hasn't been flipped already)
		CharacterFlipbookComponent->SetWorldScale3D(FVector(1.0f, 1.0f, 1.0f));
	}
}

========================================================================
34. Staying In Map Limits


========================================================================
35. Adding the Gun

Gun:
Gun will be a Sprite Component that rotates around the player
The gun will be attached to a SceneComponent

What is a "SceneComponent"?
* A SceneComponent is a Component that has a Transform (meaning, it has a Position, Rotation and Scale) and nothing else.
  * The equivalent in Unity would be "Transform"

* The Gun will also have a "Bullet Spawn Position" (i.e. a FirePoint), which will also be a SceneComponent


----
C++ 
----
#include "Components/SceneComponent.h"
#include "PaperSpriteComponent.h"

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TObjectPtr<class USceneComponent> GunParent;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TObjectPtr<class UPaperSpriteComponent> GunSprite;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TObjectPtr<class USceneComponent> BulletSpawnPosition;


----------------------------------------------------------------------------------
NOTE:
* Had an issue where I could not edit the rotation (only the scale) in the BP_Player blueprint.

These are for BLANK Details panels:

https://forums.unrealengine.com/t/solved-blank-detail-panel-for-ustaticmeshcomopnent-in-child-blueprint-class-of-a-c-class/141378/4

FIXES:
(1)
You need to re-create the Blueprint.

Anytime you remove/change components or UPROPERTY meta of a default object, you will have to regenerate the Blueprint. Sometimes reparenting helps, but either way you are likely to lose data. You can add new components without issues usually, but removing or changing existing once will break the BP.

The reason is that the UPROPERTY meta has already been serialized into the Blueprint.

Never use EditDefaultsOnly or BlueprintReadWrite on a component - only use VisibleDefaultsOnly and BlueprintReadOnly.

(2)
Instead of recreating the blueprint, renaming the component (and the display name), compile in code and opening can fix it. If you reference that comp in the blueprint itself you will probably need to relink those.

https://github.com/rweber89/BPCorruptionFix


-----------------------------
https://forums.unrealengine.com/t/static-mesh-inherited-from-c-class-only-shows-scale-option/318257

-----------------------------
Saving:
CapsuleComponent:
Capsule Half Height: 44.0
Capsule Radius: 22.0

Collision: OverlapAllDynamic (default)

-----------------------------

MY FIX:
* I made a DummyComp of type SceneComponent, attached the GunComp to that.
* The GunParentComp looked fine (meaning, it had Location, Rotation, Scale)
* I then removed the creation of DummyComp. 
* I shut down the Editor, compiled, reloaded the editor, and then it seems to have fixed it.
* Note for future: Components set in C++ should be BlueprintReadOnly. Also never EditAnywhere or EditDefaultsOnly (VisibleAnywhere and VisibleDefaultsOnly should be ok).

Note: CapsuleComponent no longer has the Location and Rotation either, but that wasn't fixed. Not sure if that is normal, however.


========================================================================
36. Rotating the Gun

Rotating the Gun:
* Use: FindLookatRotation()
* Get the PlayerPosition (P).
* Get the Mouse Position (M) in World Coordinates (convert from Screen to world)
* Get the direction from the player to the mouse:  (M - P)
* Use that direction for the look at rotation 

Getting the Mouse Position:
* APlayerController::DeprojectMousePositionToWorld
* We do not need MouseWorldDirection, but we have to pass it in anyways

FVector MouseWorldLocation, MouseWorldDirection;
PlayerController->DeprojectMousePositionToWorld(MouseWorldLocation, MouseWorldDirection);

Note:
* Need to #include "Kismet/KismetMathLibrary.h"
to use UKismetMathLibrary::FindLookAtRotation

Full Code:

	// Rotate the gun
	if (APlayerController* PlayerController = Cast<APlayerController>(Controller))
	{
		// Get the player's position in the XZ plane
		FVector CurrentLocation = GetActorLocation();
		FVector StartPos = FVector(CurrentLocation.X, 0.0f, CurrentLocation.Z);

		// Get the mouse position in world coordinates in the XZ plane
		FVector MouseWorldLocation, MouseWorldDirection;
		PlayerController->DeprojectMousePositionToWorld(MouseWorldLocation, MouseWorldDirection);
		FVector TargetPos = FVector(MouseWorldLocation.X, 0.0f, MouseWorldLocation.Z);

		// Create a rotation representing the vector from the player position to the mouse position
		FRotator GunParentRotator = UKismetMathLibrary::FindLookAtRotation(StartPos, TargetPos);

		// Set the GunParentComponent's rotation
		GunParentComp->SetRelativeRotation(GunParentRotator);
	}


----
Ensure the mouse cursor is always visible:
PlayerController->SetShowMouseCursor(true);

========================================================================
37. Creating the Bullet

C++:
#include "Components/SphereComponent.h"
#include "PaperSpriteComponent.h"

	// --- Components ---
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	TObjectPtr<class USphereComponent> SphereComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	TObjectPtr<class UPaperSpriteComponent> BulletSpriteComp;

	// Create components
	SphereComp = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComp"));
	SetRootComponent(SphereComp);

	BulletSpriteComp = CreateDefaultSubobject<UPaperSpriteComponent>(TEXT("BulletSpriteComp"));
	BulletSpriteComp->SetupAttachment(RootComponent);

========================================================================
38. Moving the Bullet

Bullet:
* MoveDirection
* MoveSpeed

Quick Implementation:
	// Update bullet movement
	FVector BulletPosition = GetActorLocation();
	FVector2D BulletPosition2D = FVector2D(BulletPosition.X, BulletPosition.Z);

	FVector2D MovementAmount = MovementDirection * MovementSpeed * DeltaTime;

	FVector NewPosition = FVector(BulletPosition2D.X, 0.0f, BulletPosition2D.Y) + FVector(MovementAmount.X, 0.0f, MovementAmount.Y);
	
	// Set the new bullet position
	SetActorLocation(NewPosition);

Course Implementation 
* Note: This doesn't take into consideration that the player might not be 0 in the Y:
	// Update bullet movement
	FVector2D DistanceToMove = MovementDirection * MovementSpeed * DeltaTime;

	FVector CurrentLocation = GetActorLocation();
	FVector NewLocation = CurrentLocation + FVector(DistanceToMove.X, 0.0f, DistanceToMove.Y);

	SetActorLocation(NewLocation);



========================================================================
39. Launching the Bullet

Timer:
GetWorldTimerManager().SetTimer


Timers:
FORCEINLINE void SetTimer(FTimerHandle& InOutHandle, UserClass* InObj, typename FTimerDelegate::TMethodPtr< UserClass > InTimerMethod, float InRate, bool InbLoop = false, float InFirstDelay = -1.f)

Destroy Actor:
Destroy();

========================================================================

